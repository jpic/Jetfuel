<refentry id="{@id}">
    <refnamediv>
        <refname>Models</refname>
        <refpurpose>The basics for building models with Jetfuel</refpurpose>
    </refnamediv>
    <refsect1 id="{@id intro}">
        <title>Introduction</title>
        <para>Jetfuel can access database objects by way of an Object-Relation mapper. Jetfuel's O-R mapper implements the Active Record pattern.</para>
        <para>Of course, if you like you can simply make direct SQL calls from your controller actions (or use any of the database access methods provided by eZComponents), but Jetfuel's model provides an quick and easy way to persist your objects to the database. Jetfuel's model is a convenience wrapper around the eZComponents PersistentObject component.</para>
        <para>Your Jetfuel model classes are stored in the app/models directory. Definition files for eZ Components are stored in app/models/definitions, and can initially be autogenerated by executing 'php core/scripts/generateschema.php' from the top-level jetfuel directory.</para>
    </refsect1>
    <refsect1 id="{@id setup}" >
        <title>Getting Started</title>
        <para>To get started with the model for your blog application, create these tables in your database:</para>
        
        <table frame="all" id="{@id post}">
            <caption>post</caption>
            <tgroup cols="3">
                <thead>
                    <row>
                        <entry>field name</entry>
                        <entry>type</entry>
                        <entry>other notes</entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry>id</entry>
                        <entry>int</entry>
                        <entry>autoindex, primary keys</entry>
                    </row>
                    <row>
                        <entry>title</entry>
                        <entry>varchar(60)</entry>
                        <entry />
                    </row>
                    <row>
                        <entry>summary</entry>
                        <entry>text</entry>
                        <entry />
                    </row>
                    <row>
                        <entry>body</entry>
                        <entry>text</entry>
                        <entry />
                    </row>
                    <row>
                        <entry>created_at</entry>
                        <entry>timestampe</entry>
                        <entry />
                    </row>
                </tbody>
            </tgroup>
           
            <table frame="all" id="{@id comment}">
                <caption>comment</caption>
                <tgroup cols="3">
                    <thead>
                        <row>
                            <entry>field name</entry>
                            <entry>type</entry>
                            <entry>other notes</entry>
                        </row>
                    </thead>
                    <tbody>
                        <row>
                            <entry>id</entry>
                            <entry>int</entry>
                            <entry>autoindex, primary keys</entry>
                        </row>
                        <row>
                            <entry>post_id</entry>
                            <entry>int</entry>
                            <entry />
                        </row>
                        <row>
                            <entry>name</entry>
                            <entry>varchar(50)</entry>
                            <entry />
                        </row>
                        <row>
                            <entry>email</entry>
                            <entry>varchar(255)</entry>
                            <entry />
                        </row>
                        <row>
                            <entry>body</entry>
                            <entry>text</entry>
                            <entry />
                        </row>
                        <row>
                            <entry>created_at</entry>
                            <entry>timestamp</entry>
                            <entry />
                        </row>
                    </tbody>
                </tgroup>

            
        <para>(For MySQL users, I recommend the create script in examples/blog/example_blog.sql that will create these tables for you and stub in a few sample records.)</para>
        <para>Now that we have our database defined, let's generate the definition files that PersistentObject needs to use these tables. Make sure that you have the correct database settings in settings/config.ini, and in your console, cd to your jetfuel directory and type:</para>
        
        <programlisting role="bash">
        <![CDATA[
            php core/scripts/createschema.php
        
        ]]>
        </programlisting>      
              
        <para>Once this completes, you should have two new files: app/models/definitions/post.php and app/models/deinitions/commments.php . These tell PersistentObject how the tables and fields in your database map to your Jetfuel model classes and attributes.</para>
        
        <para>Now that your model definition is set, create a new file called Post.php in your app/models directory, and add this code: </para>

        <programlisting role="php">
        <![CDATA[
                
        class Post extends JFPersistentObject
        {
            public $id = null;
            public $title;
            public $summary;
            public $body;
            public $created_at;
        }
        
        ]]>
        </programlisting>        
        
        <para>Let's take a look at our new Model class. We've created a new class 'Post' that extends from JFPersistentObject. We've also added public properties with names matching the fields in our 'post' database table. That's all that's required for Jetfuel to persist your objects to the database table.</para>
        
        <para>Before we get much further, let's do the same thing for the comments. Create an 'app/models/Comment.php' file and add this code: </para>
        
        <programlisting role="php">
        <![CDATA[
                
        class Comment extends JFPersistentObject
        {
            public $id = null;
            public $name;
            public $email;
            public $body;
            public $created_at;
        }
        ]]>
        </programlisting>
                
    </refsect1>
    <refsect id="{@id relations}">
        <title>Object Relations</title>
        <para>We've got the basics of our model set up, but let's make things a bit more interesting. Jetfuel can relate objects together, allowing you to navigate your object graph using simple getter methods. We'll set it up so that when we have a post object, we can do '$post->comments' to get all of its comments, and if we have a comment, '$comment->post' to get the related post.</para>
        
        <para>There are two things we need to do in order to enable this behavior: We need to update the eZComponents PersistentObject definition with the relationship, and then tell our Jetfuel model classes how to present it. We'll start with the eZC definition.</para>
        
        <para>Open up your 'app/models/definitions/post.php' file in an editor. It should look something like this:</para>
        <programlisting role="php">
        <![CDATA[
                
        &laquo;?php
        // Autogenerated PersistentObject definition

        $def = new ezcPersistentObjectDefinition();
        $def->table = 'post';
        $def->class = 'post';

        $def->properties['body']               = new ezcPersistentObjectProperty();
        $def->properties['body']->columnName   = 'body';
        $def->properties['body']->propertyName = 'body';
        $def->properties['body']->propertyType = ezcPersistentObjectProperty::PHP_TYPE_STRING;

        ... ...
        
        $def->properties['title']               = new ezcPersistentObjectProperty();
        $def->properties['title']->columnName   = 'title';
        $def->properties['title']->propertyName = 'title';
        $def->properties['title']->propertyType = ezcPersistentObjectProperty::PHP_TYPE_STRING;

        return $def;
                
        ?&raquo;
        ]]>
        </programlisting>
        
        <para>There's a bit of code at the top that maps the DB table name to the PHP class name, and a segment for each attribute that maps the DB column name to the PHP property name. If you wanted to have different names in your PHP class vs your database tables, you can adjust those here.</para>
        
        <para>Near the end of the file, just above the 'return $def' line, add this:</para>
        
        $def->relations["Comment"] = new ezcPersistentOneToManyRelation("post","comment");
        $def->relations["Comment"]->columnMap = array(new ezcPersistentSingleTableMap('id','post_id'));
        
        <para>This informs the O-R mapper that we have a one-to-many relationship between 'post' and 'comment', and that comment.post_id is the foreign key that links to post.id</para>
        
        <para>Now let's update our model file, 'app/models/Post.php' and add a little new code:</para>
        <programlisting role="php">
        <![CDATA[
               
        class Post extends JFPersistentObject
        {

            public $id = null;
            public $title;
            public $summary;
            public $body;
            public $created_at;

            public static $relations = array(
                'comments'=>array('class'=>'Comment','orderBy'=>'created_at desc')
            );
            
        }
        ]]>
        </programlisting>
                
        <para>The $relations array contains an entry for each related object. Each entry contains options for class, name, orderBy, and type. 'class' is required and tells the system which class you're relating to. 'orderBy' allows you to define what order the related items are returned in. 'type' can be set to 'single' or 'multiple'; This will determine if a single object or an array of objects is returned. 'name' sets the name of the relationship defined in the PersistentObject model. This is only needed if you've defined multiple relationships between the same two classes.</para>
        
        <para>All set. If we were to load up a post object and call '$post->comments', we'd get an array containing the comments for this post as Comment objects, with the newest one being the first in the list.</para>
        
        <para>Let's go ahead and set the reverse relation up for the Comment class:</para>
        
        <para>Add this to app/models/definitions/comment.php (above return $def): </para>
        
        $def->relations["Comment"] = new ezcPersistentOneToManyRelation("post","comment");
        $def->relations["Comment"]->columnMap = array(new ezcPersistentSingleTableMap('id','post_id'));

        <para>And to app/models/Comment.php:</para>
        
        <programlisting role="php">
        <![CDATA[     
        public static $relations = array(
            'post'=>array('class'=>'Post','type'=>'single')
        );        
        ]]>
        </programlisting>    
    </refsect1>
    
    <refsect1>
        <title>Validations</title>
        <para>One of the handiest things that Jetfuel provides is validation code. By specifying the name and type of your attributes, along with some parameters, you can tell Jetfuel to validate your objects before saving them to the database when $object->save() is called.</para>
        <para>If the object passes validation, it will be persisted to the database and the save() method will return true. If there's a problem, save() will return false, and $object->errors will be set with an array containing error messages for all of the fields that failed to validate.</para>
        
        <para>Let's add some validation to our Post class by editing 'app/models/Post.php' and adding the following:</para>
        
        <programlisting role="php">
        <![CDATA[
            public static $validations = array(
            'title'=>array(
                'type'=>'string',
                'required'=>true,
                'message'=>'Please enter a title.'
            ),
            'body'=>array(
                'type'=>'string',
                'required'=>true,
                'message'=>'Please enter a body.'
            )
        );
        ]]>
    </programlisting>
        
        <para>The static $validations variable holds an array of key-value pairs, with the key being the attribute name and the value being an array of options. Options vary by data type, but include 'type' (the data type of the object), 'required' (whether or not the attribute is required), 'message' (the message to display to the user if the attribute isn't valid). For strings, 'format' is also available (specifying a regex pattern that the input must match).</para>
        <para>The full list of options can be found in the API doc. If more complex validation i required, you may create your own validation code by overriding the  validate() method.</para>
        <para>As usual, let's go ahead and set the rules for the Comment class as well. Add this to the class in 'app/models/Comment.php':</para>
        
        <programlisting role="php">
        <![CDATA[
        public static $validations = array(
            'name'=>array(
                'type'=>'string',
                'required'=>true,
                'message'=>'Please enter your name.'
            ),
            'email'=>array(
                'type'=>'string',
                'required'=>true,
                'format'=>'/^[A-Z0-9._%-]+@[A-Z0-9.-]+\.[A-Z]{2,4}$/i',
                'message'=>'Please enter your email.'
            ),
            'body'=>array(
                'type'=>'string',
                'required'=>true,
                'message'=>'Please enter a body.'
            )
        );
        
        ]]>
        </programlisting>
        
        
        
                
        
        
</refentry>